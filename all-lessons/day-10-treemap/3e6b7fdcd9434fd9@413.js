// https://observablehq.com/@thetylerwolf/day-10-treemap@413
function _1(md){return(
md`
# Day 10 - Treemap

We're taking a leap to a whole new type of chart today with the Treemap. These aesthetically-pleasing charts are easier to make than you might think. We'll take some time to understand the data structure behind them and how it's used to generate the graphic.
`
)}

function _2(md){return(
md `### 25 days of D3
*This notebook is part of [25 Days of D3.js](https://medium.com/@tylernwolf/25-days-of-d3-js-de5419874e79), a series of 25 lessons that will take you from absolute beginner to an expert in D3. If you haven't, check out the [introductory blog post](https://medium.com/@tylernwolf/25-days-of-d3-js-de5419874e79). 25 Days of D3.js is from [Tyler Wolf](https://tylernwolf.com).*`
)}

function _3(md){return(
md `
# Introduction

Like the stacked bar chart, treemaps are good for comparing categories of things composed of smaller data points. Treemaps make it easy to compare both the main category's total value and the value of its children. When there are too many categories, a stacked bar chart can become difficult to use for meaningful comparisons, so a treemap can be a good alternative. Scroll down to see what our treemap looks like.

As I mentioned, we'll take the time to understand the hierarchical data structure behind the treemap before we dive into placing the graphics. Once we understand the data, the process of drawing the chart becomes much easier to understand.
`
)}

function _4(md){return(
md `
## Hierarchical Data

If you've done a lot of programming, you've likely come across hierarchical data in some form - it's often referred to as a tree data structure. Basically, it has a root object (node) with an array of children objects (nodes). Each of those children nodes may have its own children nodes and so on. A child node with no children is referred to as a leaf and the topmost node is referred to as the root.

When we generate our own data hierarchy, we don't have to worry about more than including the children on each node and any additional data that may be useful about that node.

In our data set, I've taken a flat CSV of data about electricity production in seven different countries and converted it into a tree structure.

The root node of the hierarchy holds all of the countries' data as children - we can refer to that as the world node. The children of the world node are the countries; they have a name and their own children. The children of each country are the energy production sources in that country and are leaf nodes. Each leaf node has a name and a value attached to it.
`
)}

function _5(md){return(
md `
With this data, we'll use a treemap to visualize how much energy each country produces in GWh and the composition of that total amount in GWh by energy production source. Take a look at the \`\`data\`\` object to get a feel for how things are structured.

Data Source: [IEA Electricity Information 2019](https://webstore.iea.org/electricity-information-2019)
`
)}

async function _data(d3,FileAttachment)
{

  const d = d3.csvParse(await FileAttachment("Electricity generation by source@1.csv").text())
  
  const children = d.map(country => ({
    name: country.Country,
    children: Object.entries(country).map(c => {
      if(c[0] == '' || c[0] == 'Country' || c[0] == 'Year') return
      
      else return { 
        name: c[0],
        value: c[1] 
      }
    }).filter(d => d)
  }))
  
  return {
    children
  }
  
}


function _width(){return(
900
)}

function _height(){return(
700
)}

function _margin(){return(
{
  top: 10,
  right: 10,
  bottom: 10,
  left: 10
}
)}

function _colorScale(d3){return(
d3.scaleOrdinal( d3.schemeSet2 )
)}

function _11(md){return(
md `
\`\`d3.hierarchy()\`\` is a generator like all generators we've seen before, but unlike the other generators we've seen, this one generates a data structure. Or rather, this one performs operations on our data structure to prepare it for use elsewhere.

What does it \`\`d3.hierarchy()\`\` change about the original object? If you inspect the object, you'll see the following keys:

\`\`data\`\`: This is the original version of this node - we can use it to access data like the \`\`name\`\` of the node

\`\`height\`\`: This is the count of children "generations" beneath this node

\`\`depth\`\`: The count of parent nodes above this one

\`\`parent\`\`: This node's parent node

\`\`children\`\`: This node's children nodes

\`\`value\`\`: The value of this node, which is the sum of the values of its children nodes

*You'll notice additional data on children nodes. That's generated by the treemap in the next step, so ignore it for this moment.*

**On the hierarchy**, we also call \`\`.sum()\`\` and \`\`.sort()\`\`.

\`\`.sum()\`\` tells the hierarchy to sum the values of the child nodes up the tree - this must be called in order for the hierarchy to be generated and it is passed an accessor function for locating the value of a given node.

\`\`.sort()\`\` sorts the nodes at each depth based on the sort function. This sort function orders the nodes by decreasing value.

The returned hierarchy root node has a variety of convenience functions (we'll use one later) to make working with the data easier. You can learn more about \`\`d3.hierarchy()\`\` [here](https://github.com/d3/d3-hierarchy/blob/v1.1.9/README.md#hierarchy)

**note** In the code below, I use \`\`JSON.parse( JSON.stringify( data ) )\`\` to make a "deep copy" of the original data object. This is not necessary for things to work. I used it because \`\`d3.hierarchy()\`\` modifies the original data object passed to it and I'm keeping our original data object untouched so you can compare the difference.
`
)}

function _hierarchy(data,d3)
{
  const dataCopy = JSON.parse( JSON.stringify( data ) )

  return d3.hierarchy( dataCopy )
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value)
}


function _13(md){return(
md `
Now we call the next Data structure generator, \`\`d3.treemap()\`\`. This one returns a function that takes our hierarchy as an argument. It then returns a modified copy of the hierarchy. This time, the following keys are added to each node except for the root node:
**x0**, **x1**, **y0**, **y1**

These keys correspond to the dimensions of the rectangles that compose our treemap. \`\`x0\`\` is the x-position of the left edge of the rectangle, \`\`x1\`\` is the right edge, \`\`y0\`\` is the y-position of the top edge and \`\`y1\`\` is the bottom edge. Using those four points, we can generate our rectangles.

\`\`d3.treemap()\`\` has much more customizability, including the sizing/placement algorithm - you can learn more about \`\`d3.treemap()\`\` [here](https://github.com/d3/d3-hierarchy/blob/v1.1.9/README.md#treemap)
`
)}

function _treemap(d3,width,height){return(
d3.treemap()
    // set the size of the treemap render area
    .size([ width, height ])
    // set the padding between every rectangle in px
    .padding(2)
    // set the padding at the top of each group of rectangles
    // so that we can fit the country labels
    .paddingTop(10)
    // Set the generator to round pixel values to the nearest value
    // (makes things look better)
    .round(true)
)}

function _15(md){return(
md `
Here, we actually pass the hierarchy data to the treemap generator and voila! Treemap data is ready.
`
)}

function _root(treemap,hierarchy){return(
treemap( hierarchy )
)}

function _chart(d3,width,height,root,colorScale)
{

  const svg = d3.create('svg')
      .style('font-family', 'sans-serif')
      .attr('width', width)
      .attr('height', height)

  const g = svg.append('g')
      .attr('class', 'treemap-container')
  
  // Place the labels for our countries
  g.selectAll('text.country')
    // The data is the first "generation" of children
    .data( root.children )
    .join('text')
      .attr('class', 'country')
      // The rest is just placement/styling
      .attr('x', d => d.x0)
      .attr('y', d => d.y0)
      .attr('dy', '0.6em')
      .attr('dx', 3)
      .style('font-size', 12)
    // Remember, the data on the original node is available on node.data (d.data here)
    .text(d => d.data.name)
  
  // Now, we place the groups for all of the leaf nodes
  const leaf = g.selectAll('g.leaf')
    // root.leaves() returns all of the leaf nodes
    .data(root.leaves())
    .join('g')
      .attr('class', 'leaf')
      // position each group at the top left corner of the rect
      .attr('transform', d => `translate(${ d.x0 },${ d.y0 })`)
      .style('font-size', 10)

  // A title element tells the browser to display its text value
  // in a popover when the cursor is held over a rect. This is a simple
  // way to add some interactivity
  leaf.append('title')
    .text(d => `${ d.parent.data.name }-${ d.data.name }\n${ d.value.toLocaleString() + ' GWh' }`)

  // Now we append the rects. Nothing crazy here
  leaf.append('rect')
      .attr('fill', d => colorScale(d.parent.data.name))
      .attr('opacity', 0.7)
      // the width is the right edge position - the left edge position
      .attr('width', d => d.x1 - d.x0)
      // same for height, but bottom - top
      .attr('height', d => d.y1 - d.y0)
      // make corners rounded
      .attr('rx', 3)
      .attr('ry', 3)

  // This next section checks the width and height of each rectangle
  // If it's big enough, it places labels. If not, it doesn't.
  leaf.each((d, i, arr) => {
  
    // The current leaf element
    const current = arr[i]
    
    const left = d.x0,
          right = d.x1,
          // calculate its width from the data
          width = right - left,
          top = d.y0,
          bottom = d.y1,
          // calculate its height from the data
          height = d.y1 - d.y0

    // too small to show text
    const tooSmall = width < 34 || height < 25
    
    // and append the text (you saw something similar with the pie chart (day 6)
    const text = d3.select( current ).append('text')
        // If it's too small, don't show the text
        .attr('opacity', tooSmall ? 0 : 0.9)
      .selectAll('tspan')
      .data(d => [ d.data.name, d.value.toLocaleString() ])
      .join('tspan')
        .attr('x', 3)
        .attr('y', (d,i) => i ? '2.5em' : '1.15em')
        .text(d => d)

  })
  
  return svg.node();

}


function _18(md){return(
md `
# Conclusion

As you can see, rendering the treemap was pretty straightforward. The trickiest part was understanding the data and how its generated. As always, understanding these concepts may take some time and effort, but a solid understanding goes a long, long way.

See you [tomorrow](https://observablehq.com/@thetylerwolf/day-11-introduction-to-animations?collection=@thetylerwolf/25-days-of-d3)!

-Tyler
`
)}

function _19(md){return(
md `
If you find these lessons useful, the most helpful thing you can do is **share them on social media**. You can find me on twitter - [@tylernwolf](https://twitter.com/tylernwolf) - and **follow me if you'd like to stay updated when new lessons are released**. Also, don't hesitate to **tweet at me** if you have any questions, comments or ideas!
`
)}

function _d3(require){return(
require('d3@6')
)}

function _end()
{
  const script = document.createElement('script');
  script.src = 'https://www.googletagmanager.com/gtag/js?id='+atob('Ry1ZSk5YRDNIUlAx');
  script.type = 'text/javascript';
  script.async = true;

  script.onload = () => {
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      var dataLayer = window.dataLayer;
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', atob('Ry1ZSk5YRDNIUlAx'));
  };
  document.body.appendChild(script);
}


export default function define(runtime, observer) {
  const main = runtime.module();
  function toString() { return this.url; }
  const fileAttachments = new Map([
    ["Electricity generation by source@1.csv", {url: new URL("./files/e7a92468c9844d0d81f4a928081bd31df37163d83f0f79ccc31e8cad6001573af18619318b687d48ee947a5001fb02ff8033d643d8569b1d66876ecaff453c4c.csv", import.meta.url), mimeType: "text/csv", toString}]
  ]);
  main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
  main.variable(observer()).define(["md"], _1);
  main.variable(observer()).define(["md"], _2);
  main.variable(observer()).define(["md"], _3);
  main.variable(observer()).define(["md"], _4);
  main.variable(observer()).define(["md"], _5);
  main.variable(observer("data")).define("data", ["d3","FileAttachment"], _data);
  main.variable(observer("width")).define("width", _width);
  main.variable(observer("height")).define("height", _height);
  main.variable(observer("margin")).define("margin", _margin);
  main.variable(observer("colorScale")).define("colorScale", ["d3"], _colorScale);
  main.variable(observer()).define(["md"], _11);
  main.variable(observer("hierarchy")).define("hierarchy", ["data","d3"], _hierarchy);
  main.variable(observer()).define(["md"], _13);
  main.variable(observer("treemap")).define("treemap", ["d3","width","height"], _treemap);
  main.variable(observer()).define(["md"], _15);
  main.variable(observer("root")).define("root", ["treemap","hierarchy"], _root);
  main.variable(observer("chart")).define("chart", ["d3","width","height","root","colorScale"], _chart);
  main.variable(observer()).define(["md"], _18);
  main.variable(observer()).define(["md"], _19);
  main.variable(observer("d3")).define("d3", ["require"], _d3);
  main.variable(observer("end")).define("end", _end);
  return main;
}
